<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nova 源码解析</title>
      <link href="/2024/06/09/nova_source_code/"/>
      <url>/2024/06/09/nova_source_code/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">path</th><th align="right">files</th><th align="right">code</th><th align="right">comment</th><th align="right">blank</th><th align="right">total</th></tr></thead><tbody><tr><td align="left">.</td><td align="right">312</td><td align="right">49,225</td><td align="right">2,859</td><td align="right">8,490</td><td align="right">60,574</td></tr><tr><td align="left">CGInc</td><td align="right">2</td><td align="right">367</td><td align="right">5</td><td align="right">69</td><td align="right">441</td></tr><tr><td align="left">Editor</td><td align="right">21</td><td align="right">6,536</td><td align="right">572</td><td align="right">1,114</td><td align="right">8,222</td></tr><tr><td align="left">Lua</td><td align="right">25</td><td align="right">2,209</td><td align="right">121</td><td align="right">291</td><td align="right">2,621</td></tr><tr><td align="left">Settings</td><td align="right">2</td><td align="right">246</td><td align="right">0</td><td align="right">0</td><td align="right">246</td></tr><tr><td align="left">Sources</td><td align="right">257</td><td align="right">39,584</td><td align="right">2,155</td><td align="right">6,967</td><td align="right">48,706</td></tr><tr><td align="left">Sources\Core</td><td align="right">82</td><td align="right">8,917</td><td align="right">887</td><td align="right">1,706</td><td align="right">11,510</td></tr><tr><td align="left">Sources\Core\Animation</td><td align="right">21</td><td align="right">1,248</td><td align="right">65</td><td align="right">229</td><td align="right">1,542</td></tr><tr><td align="left">Sources\Core\Collections</td><td align="right">3</td><td align="right">268</td><td align="right">10</td><td align="right">55</td><td align="right">333</td></tr><tr><td align="left">Sources\Core\Input</td><td align="right">7</td><td align="right">731</td><td align="right">24</td><td align="right">119</td><td align="right">874</td></tr><tr><td align="left">Sources\Core\Restoration</td><td align="right">18</td><td align="right">1,755</td><td align="right">144</td><td align="right">330</td><td align="right">2,229</td></tr><tr><td align="left">Sources\Core\ScriptParsing</td><td align="right">12</td><td align="right">2,050</td><td align="right">327</td><td align="right">387</td><td align="right">2,764</td></tr><tr><td align="left">Sources\Core\VFX</td><td align="right">5</td><td align="right">415</td><td align="right">27</td><td align="right">85</td><td align="right">527</td></tr><tr><td align="left">Sources\Exceptions</td><td align="right">3</td><td align="right">30</td><td align="right">3</td><td align="right">6</td><td align="right">39</td></tr><tr><td align="left">Sources\Generate</td><td align="right">1</td><td align="right">769</td><td align="right">1</td><td align="right">6</td><td align="right">776</td></tr><tr><td align="left">Sources\Scripts</td><td align="right">111</td><td align="right">9,200</td><td align="right">253</td><td align="right">1,814</td><td align="right">11,267</td></tr><tr><td align="left">Sources\Scripts\Controllers</td><td align="right">10</td><td align="right">1,476</td><td align="right">54</td><td align="right">306</td><td align="right">1,836</td></tr><tr><td align="left">Sources\Scripts\Graphics</td><td align="right">3</td><td align="right">236</td><td align="right">16</td><td align="right">48</td><td align="right">300</td></tr><tr><td align="left">Sources\Scripts\SpriteCropping</td><td align="right">3</td><td align="right">35</td><td align="right">1</td><td align="right">8</td><td align="right">44</td></tr><tr><td align="left">Sources\Scripts\UI</td><td align="right">68</td><td align="right">6,039</td><td align="right">159</td><td align="right">1,173</td><td align="right">7,371</td></tr><tr><td align="left">Sources\ThirdParty</td><td align="right">60</td><td align="right">20,668</td><td align="right">1,011</td><td align="right">3,435</td><td align="right">25,114</td></tr></tbody></table><h2 id="剧本解析器"><a href="#剧本解析器" class="headerlink" title="剧本解析器"></a>剧本解析器</h2><p><code>Sources\CoreScriptParsing</code>：2000 line</p><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>Parser首先会创建一个Tokenizer对象负责解析剧本文件的标识符，再根据标识符将剧本文件分为若干块，如提前代码块（EagerCodeBlock）、代码块（CodeBlock）、文本块（TextBlock）、分隔块（SeparatorBlock）。</p><p>解析好的块被称为ParsedScript，在游戏运行时被交给 <code>ScriptLoader</code> 进行执行。</p><span id="more"></span><pre><code class="highlight mermaid">graph TD;Start --&gt; ParseBlockParseBlock --&gt; ParseEagerExectionBlockParseBlock --&gt; ParseCodeBlockParseBlock --&gt; ParseCodeBlockWithAttributesParseBlock --&gt; CheckTokenTypeCheckTokenType --&gt;|WhiteSpace| WhiteSpaceCheckTokenType --&gt;|NewLine or EOF| NewLineOREOF[&quot;NewLine or EOF&quot;]CheckTokenType --&gt;|Not Whitespace or NewLine or EOF| ParseTextBlockWhiteSpace --&gt; CheckTokenTypeNewLineOREOF --&gt; AddToBlocksParseTextBlock --&gt; AddToBlocksParseEagerExectionBlock --&gt; ParseCodeBlockParseCodeBlockWithAttributes --&gt; ParseCodeBlockParseCodeBlock --&gt; AddToBlocks[&quot;Add To Blocks&quot;]AddToBlocks --&gt; ReturnParsedScript[&quot;Return ParsedScript&quot;]</code></pre><h3 id="FlowChartGraph"><a href="#FlowChartGraph" class="headerlink" title="FlowChartGraph"></a>FlowChartGraph</h3><p>在游戏启动时，ScriptLoader 将加载并解析剧情脚本以构建 FlowChartGraph，每一个 FlowChartGraph 由多个 FlowChartNode 构成，每一个 FlowChartNode 又包含有多个 DialogueEntry，当玩家点击下一步时，其实实际上就是在不断地向前加载 DialogueEntry。</p><pre><code class="highlight mermaid">flowchart TDFlowChartGraph --&gt; Node1FlowChartGraph --&gt; Node2FlowChartGraph --&gt; Node3Node1 --&gt; Entry1Node1 --&gt; Entry2Node1 --&gt; Entry3Node2 --&gt; Entry4Node2 --&gt; Entry5Node2 --&gt; Entry6Node3 --&gt; Entry7Node3 --&gt; Entry8Node3 --&gt; Entry9</code></pre><h2 id="演出控制"><a href="#演出控制" class="headerlink" title="演出控制"></a>演出控制</h2><p>Nova通过GameViewInput获取玩家的输入，然后顺序调用一系列管理器，最终更新界面显示。</p><pre><code class="highlight mermaid">flowchart LRsubgraph &quot;InputCheck&quot;ClickForward(&quot;GameViewInput.ClickForward()&quot;)--&gt; GameViewController.Step(&quot;GameViewController.Step()&quot;)endInputCheck --&gt; GameStatesubgraph &quot;GameState&quot;    direction TBGameState.Step(&quot;GameState.Step()&quot;)--&gt; GameState.UpdateGameState(&quot;GameState.UpdateGameState()&quot;)--&gt; GameState.ExecuteAction(&quot;GameState.ExecuteAction()&quot;)--&gt; UpdateDialogue(&quot;GameState.UpdateDialogue()&quot;)endGameState --&gt; DialogueEntrysubgraph &quot;DialogueEntry&quot;direction TBDialogueEntry.ExecuteAction(&quot;DialogueEntry.ExecuteAction()&quot;)--&gt; DialogueEntry.action.Call(&quot;DialogueEntry.action.Call()&quot;)end</code></pre><h3 id="VFX"><a href="#VFX" class="headerlink" title="VFX"></a>VFX</h3><p>Nova的图像特效，例如淡入淡出等，都是通过VFX实现的，以下我们就将对Nova的VFX系统的代码进行分析。</p><h4 id="lua-function-vfx"><a href="#lua-function-vfx" class="headerlink" title="lua function - vfx"></a>lua function - vfx</h4><p>在影视制作中，在真人动作镜头之外创造或操纵图像的过程被称为VFX（Visual effects）。利用影片和电脑生成的图像或影像合成，来创造一个看起来真实的效果或场景。而在视觉小说中，往往是指为图像添加某些视觉效果。</p><p>Nova 作为视觉小说框架自然也提供了一些相关的功能，如果我们要为图像对象添加一些特效，可以使用 <code>vfx</code> 方法，以下是一个简单的示例代码，它会为当前的背景图片添加一个模糊的效果。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">vfx(bg, <span class="string">&#x27;lens_blur&#x27;</span>, <span class="number">1</span>, &#123; _Size = <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure><p>我们可以看一看在lua代码中，<code>vfx</code> 是如何实现的。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- usage:</span></span><br><span class="line"><span class="comment">---     vfx(obj, &#x27;shader_name&#x27;, [t, &#123; name = value &#125;])</span></span><br><span class="line"><span class="comment">---     vfx(obj, &#123;&#x27;shader_name&#x27;, layer_id&#125;, [t, &#123; name = value &#125;])</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vfx</span><span class="params">(obj, shader_layer, t, properties)</span></span></span><br><span class="line">    <span class="keyword">local</span> shader_name, layer_id = parse_shader_layer(shader_layer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 如果 shader_name 存在，调用 get_mat 函数获取材质、基础着色器名称和其他信息。</span></span><br><span class="line">    <span class="comment">--- 如果 shader_name 不存在，调用 get_default_mat 函数获取对象的默认材质，并将其应用到指定层。</span></span><br><span class="line">    <span class="keyword">if</span> shader_name <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> mat, base_shader_name, _ = get_mat(obj, shader_name)</span><br><span class="line">        <span class="comment">-- 如果 t 没有提供，则时间默认为1</span></span><br><span class="line">        <span class="comment">-- 如果 properties 没有提供，则默认为空表。</span></span><br><span class="line">        t = t <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">        properties = properties <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 如果 properties 不是 &#x27;cont&#x27;，调用相关方法来设置材质的默认属性和当前属性。</span></span><br><span class="line">        <span class="keyword">if</span> properties ~= <span class="string">&#x27;cont&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            set_mat_default_properties(mat, base_shader_name, properties)</span><br><span class="line">            set_mat_properties(mat, base_shader_name, properties)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 为材质设置其运行时间</span></span><br><span class="line">        mat:SetFloat(<span class="string">&#x27;_T&#x27;</span>, t)</span><br><span class="line">        <span class="comment">-- 将该材质应用到对象的指定层</span></span><br><span class="line">        set_mat(obj, mat, layer_id)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        set_mat(obj, get_default_mat(obj), layer_id)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道，vfx 的原理就是为需要特效的对象添加一个材质，再通过该材质上的着色器属性来实现视觉效果。</p><p>但是此时我们仍有许多疑问，例如 lua 究竟是如何在代码中为对象添加材质的，而着色器又是如何生效的，如果我们要创建一个自己的着色器，又应该如何做。</p><h4 id="lua-function-get-mat"><a href="#lua-function-get-mat" class="headerlink" title="lua function - get_mat"></a>lua function - get_mat</h4><p>首先我们需要看一下 <code>get_mat</code> 方法，该方法的主要作用是从附加到 <code>GameObject</code> 的 <code>MaterialPool</code> 中获取材质。</p><ol><li>检查 <code>shader_name</code> 是否为 <code>nil</code>，如果是则返回 <code>nil</code>。</li><li>设置 <code>restorable</code> 的默认值为 <code>true</code>。</li><li>获取目标 <code>GameObject</code> 的渲染组件和后处理组件。如果两个组件都不存在，则发出警告并返回 <code>nil</code>。</li><li>获取完整的着色器名称、基础着色器名称和变体。</li><li>确保 <code>GameObject</code> 有一个材质池，并从材质池中获取可恢复或普通材质。</li><li>如果找不到材质，发出警告并返回 <code>nil</code>。如果找到材质，则返回材质、基础着色器名称和变体。</li></ol><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- get material from the MaterialPool attached to the GameObject</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">get_mat</span><span class="params">(obj, shader_name, restorable)</span></span></span><br><span class="line">    <span class="keyword">if</span> shader_name == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> restorable == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        restorable = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 获取渲染组件</span></span><br><span class="line">    <span class="keyword">local</span> go, renderer, pp = get_renderer_pp(obj)</span><br><span class="line">    <span class="keyword">if</span> renderer == <span class="literal">nil</span> <span class="keyword">and</span> pp == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        warn(<span class="string">&#x27;Cannot find SpriteRenderer or Image or RawImage or PostProcessing for &#x27;</span> .. <span class="built_in">dump</span>(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 获取完整的着色器名称</span></span><br><span class="line">    <span class="keyword">local</span> full_shader_name, base_shader_name, variant = get_full_shader_name(shader_name, obj, pp)</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 调用 Nova.MaterialPool.Ensure 函数，确保 GameObject 有一个MaterialPool，并返回材质池。</span></span><br><span class="line">    <span class="keyword">local</span> pool = Nova.MaterialPool.Ensure(go)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 获取材质</span></span><br><span class="line">    <span class="keyword">local</span> mat</span><br><span class="line">    <span class="keyword">if</span> restorable <span class="keyword">then</span></span><br><span class="line">        mat = pool:GetRestorableMaterial(full_shader_name)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mat = pool:Get(full_shader_name)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mat == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        warn(<span class="string">&#x27;Cannot find material: &#x27;</span> .. shader_name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mat, base_shader_name, variant</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="lua-function-set-mat"><a href="#lua-function-set-mat" class="headerlink" title="lua function - set_mat"></a>lua function - set_mat</h4><p><code>set_mat</code> 用于设置对象的材质（material）。它接受四个参数：obj（目标对象）、mat（材质）、layer_id（层ID，默认值为0）、token（令牌，默认值为-1）。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">set_mat</span><span class="params">(obj, mat, layer_id, token)</span></span></span><br><span class="line">    layer_id = layer_id <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    token = token <span class="keyword">or</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取目标对象的渲染器（renderer）和后处理组件（pp）</span></span><br><span class="line">    <span class="keyword">local</span> go, renderer, pp = get_renderer_pp(obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment">--- 设置材质给后处理组件</span></span><br><span class="line">    <span class="keyword">if</span> renderer <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> layer_id ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            warn(<span class="string">&#x27;layer_id should be 0 for SpriteRenderer or Image or RawImage&#x27;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        renderer.material = mat</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 如果存在后处理组件（pp）</span></span><br><span class="line">    <span class="keyword">if</span> pp <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> mat <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> pp:SetLayer(layer_id, mat)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp:ClearLayer(layer_id, token)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果存在 FadeController 组件则提示开发者不能设置 FadeController 的材质</span></span><br><span class="line">    <span class="keyword">local</span> fade = go:GetComponent(typeof(Nova.FadeController))</span><br><span class="line">    <span class="keyword">if</span> fade <span class="keyword">then</span></span><br><span class="line">        warn(<span class="string">&#x27;Cannot set material for FadeController &#x27;</span> .. <span class="built_in">dump</span>(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    warn(<span class="string">&#x27;Cannot find SpriteRenderer or Image or RawImage or PostProcessing for &#x27;</span> .. <span class="built_in">dump</span>(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="lua-function-trans2"><a href="#lua-function-trans2" class="headerlink" title="lua function - trans2"></a>lua function - trans2</h4><p><code>trans2</code> 方法由 action_begin、action_middle、action_end 三部分组成，并最终用动画系统将这三部分组合在一起。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- sprite transition using a shader that hides the texture</span></span><br><span class="line"><span class="comment">--- the shader should implement _MainTex and _T</span></span><br><span class="line"><span class="comment">--- range of _T is (0, 1), _T = 0 shows _MainTex, _T = 1 hides _MainTex</span></span><br><span class="line"><span class="comment">--- usage:</span></span><br><span class="line"><span class="comment">---     trans2(obj, &#x27;image_name&#x27;, &#x27;shader_name&#x27;, [duration, &#123; name = value &#125;, duration2, &#123; name = value &#125;, &#123;r, g, b, [a]&#125;])</span></span><br><span class="line">make_anim_method(<span class="string">&#x27;trans2&#x27;</span>, <span class="function"><span class="keyword">function</span><span class="params">(self, obj, image_name, shader_layer, times, properties, times2, properties2, color2)</span></span></span><br><span class="line">    <span class="keyword">local</span> shader_name, layer_id = parse_shader_layer(shader_layer, cam_trans_layer_id)</span><br><span class="line">    <span class="comment">-- mat is not RestorableMaterial</span></span><br><span class="line">    <span class="keyword">local</span> mat, base_shader_name, _ = get_mat(obj, shader_name, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">local</span> duration, easing = parse_times(times)</span><br><span class="line">    properties = properties <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> duration2, easing2 = parse_times(times2)</span><br><span class="line">    properties2 = properties2 <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> action_begin, action_middle, action_end, token</span><br><span class="line">    <span class="keyword">if</span> obj:GetType() == typeof(Nova.CameraController) <span class="keyword">then</span></span><br><span class="line">        action_begin = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            set_mat_default_properties(mat, base_shader_name, properties)</span><br><span class="line">            set_mat_properties(mat, base_shader_name, properties)</span><br><span class="line">            mat:SetFloat(<span class="string">&#x27;_T&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">            token = set_mat(obj, mat, layer_id)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        action_middle = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="keyword">if</span> image_name <span class="keyword">then</span></span><br><span class="line">                auto_fade_off()</span><br><span class="line">                <span class="keyword">local</span> func = image_name</span><br><span class="line">                func()</span><br><span class="line">                auto_fade_on()</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            set_mat_properties(mat, properties2)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        action_end = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            set_mat(obj, get_default_mat(obj), layer_id, token)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        action_begin = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            set_mat_default_properties(mat, base_shader_name, properties)</span><br><span class="line">            set_mat_properties(mat, base_shader_name, properties)</span><br><span class="line">            mat:SetFloat(<span class="string">&#x27;_T&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">            token = set_mat(obj, mat)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        action_middle = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="keyword">if</span> image_name <span class="keyword">then</span></span><br><span class="line">                show_no_fade(obj, image_name, <span class="literal">nil</span>, color2)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            set_mat_properties(mat, properties2)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        action_end = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            set_mat(obj, get_default_mat(obj), <span class="literal">nil</span>, token)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> entry = <span class="built_in">self</span>:action(action_begin</span><br><span class="line">        ):_then(Nova.MaterialFloatAnimationProperty(mat, <span class="string">&#x27;_T&#x27;</span>, <span class="number">1</span>)):_with(easing):_for(duration</span><br><span class="line">        ):action(action_middle</span><br><span class="line">        ):_then(Nova.MaterialFloatAnimationProperty(mat, <span class="string">&#x27;_T&#x27;</span>, <span class="number">0</span>)):_with(easing2):_for(duration2</span><br><span class="line">        ):action(action_end)</span><br><span class="line">    entry.head = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> entry</span><br><span class="line"><span class="keyword">end</span>, add_preload_pattern)</span><br></pre></td></tr></table></figure><h4 id="MaterialFactory"><a href="#MaterialFactory" class="headerlink" title="MaterialFactory"></a>MaterialFactory</h4><p>MaterialFactory 用于创建和管理 Unity 中的 <code>Material</code> 对象以及自定义的 <code>RestorableMaterial</code> 对象。lua 代码中的 <code>get_mat</code> 所使用的 <code>Get</code> 方法其实就是调用的该类中的方法。</p><p>其实现原理非常简单，从 Resources 中寻找文件名对应的 Shader，使用该 Shader 创建一个材质，最后返回。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MaterialFactory</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">string</span>, Material&gt; materials;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">string</span>, RestorableMaterial&gt; restorableMaterials;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaterialFactory</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        materials = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Material&gt;();</span><br><span class="line">        restorableMaterials = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, RestorableMaterial&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Material <span class="title">Get</span>(<span class="params"><span class="built_in">string</span> shaderName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (materials.TryGetValue(shaderName, <span class="keyword">out</span> <span class="keyword">var</span> mat)) <span class="keyword">return</span> mat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> shader = Shader.Find(shaderName);</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;Nova: Shader not found: <span class="subst">&#123;shaderName&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mat = <span class="keyword">new</span> Material(shader)</span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="built_in">string</span>.Format(<span class="string">&quot;Nova - &#123;0&#125;&quot;</span>,</span><br><span class="line">                shaderName.Substring(shaderName.IndexOf(<span class="string">&quot;/&quot;</span>, StringComparison.Ordinal) + <span class="number">1</span>)),</span><br><span class="line">            hideFlags = HideFlags.DontSave</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        materials.Add(shaderName, mat);</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestorableMaterial <span class="title">GetRestorableMaterial</span>(<span class="params"><span class="built_in">string</span> shaderName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (restorableMaterials.TryGetValue(shaderName, <span class="keyword">out</span> <span class="keyword">var</span> resMat)) <span class="keyword">return</span> resMat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> shader = Shader.Find(shaderName);</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;Nova: Shader not found: <span class="subst">&#123;shaderName&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        resMat = <span class="keyword">new</span> RestorableMaterial(shader)</span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="built_in">string</span>.Format(<span class="string">&quot;Nova:Restorable - &#123;0&#125;&quot;</span>,</span><br><span class="line">                shaderName.Substring(shaderName.IndexOf(<span class="string">&quot;/&quot;</span>, StringComparison.Ordinal) + <span class="number">1</span>)),</span><br><span class="line">            hideFlags = HideFlags.DontSave</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        restorableMaterials.Add(shaderName, resMat);</span><br><span class="line">        <span class="keyword">return</span> resMat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> m <span class="keyword">in</span> materials.Values)</span><br><span class="line">        &#123;</span><br><span class="line">            Utils.DestroyObject(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        materials.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> m <span class="keyword">in</span> restorableMaterials.Values)</span><br><span class="line">        &#123;</span><br><span class="line">            Utils.DestroyObject(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        restorableMaterials.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MaterialPool"><a href="#MaterialPool" class="headerlink" title="MaterialPool"></a>MaterialPool</h4><p>MaterialPool 使用 <code>MaterialFactory</code> 实例来管理材质对象，旨在与 Unity 引擎中的游戏对象一起使用，提供一种简化的材质管理方式。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ExportCustomType</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MaterialPool</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Keep Renderer&#x27;s default material, used when turning off VFX on the Renderer</span></span><br><span class="line">    <span class="comment">// defaultMaterial is null for PostProcessing</span></span><br><span class="line">    <span class="keyword">private</span> Material _defaultMaterial;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material defaultMaterial</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _defaultMaterial;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_defaultMaterial == <span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Utils.DestroyObject(_defaultMaterial);</span><br><span class="line">            _defaultMaterial = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TryGetComponent&lt;Renderer&gt;(<span class="keyword">out</span> <span class="keyword">var</span> renderer))</span><br><span class="line">        &#123;</span><br><span class="line">            defaultMaterial = renderer.material;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        defaultMaterial = <span class="literal">null</span>;</span><br><span class="line">        factory.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> MaterialFactory factory = <span class="keyword">new</span> MaterialFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Material <span class="title">Get</span>(<span class="params"><span class="built_in">string</span> shaderName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.Get(shaderName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestorableMaterial <span class="title">GetRestorableMaterial</span>(<span class="params"><span class="built_in">string</span> shaderName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.GetRestorableMaterial(shaderName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Export to Lua</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MaterialPool <span class="title">Ensure</span>(<span class="params">GameObject gameObject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gameObject.Ensure&lt;MaterialPool&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h2><p>Nova 的 I18n 可以分为 UI 的 I18n 与剧本的 I18n，需要分别进行讨论。</p><h3 id="I18n-UI"><a href="#I18n-UI" class="headerlink" title="I18n UI"></a>I18n UI</h3><h4 id="I18nText-I18nImage"><a href="#I18nText-I18nImage" class="headerlink" title="I18nText &amp; I18nImage"></a>I18nText &amp; I18nImage</h4><p>UI组件的I18n支持比较简单，在初始化或者I18n更改事件发生时，通过 <code>inflateKey</code> 读取多语言文件中的对应的 <code>value</code> 并更新显示。</p><pre><code class="highlight mermaid">flowchart TDI18nComponentInit(&quot;I18n Component Init&quot;)--&gt;|Get I18n Res with __ function| I18nsubgraph I18nLoadTranslationBundles(&quot;Load I18n Res&quot;)--&gt; GetCurrentLanguage(&quot;Get Current Language&quot;)--&gt; ReturnInflateResources(&quot;Return Inflate Key Res&quot;)endI18n --&gt; UpdateI18nComponent(&quot;I18nXXX.UpdateXXX&quot;)</code></pre><h3 id="I18n-Scenarios"><a href="#I18n-Scenarios" class="headerlink" title="I18n Scenarios"></a>I18n Scenarios</h3><p>在Nova中，剧本的多语言采用的是逐行对照的方式，当需要加载某个语言的多语言设置时，系统将尝试读取对应语言的对应章节的对应行。</p><h2 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a>动画系统</h2><p>动画系统有 c# 代码中的部分和 lua 中的部分，c# 中主要依靠NovaAnimation与AnimationEntry 两个组件进行控制，而<code>animation.lua</code> 中的内容，主要是对 c# 中的代码进行一层包装，为了方便处理一些参数的默认值。</p><p><code>make_anim_method</code> 它会把一个函数添加到 <code>NovaAnimation</code>和 <code>AnimationEntry</code> 的 <code>metatable</code>，这样就可以当<code>method</code>来用。</p><p>我们在演出脚本里写 <code>anim:move(xxx)</code> 的时候，其实<code> anim</code> 是 <code>NovaAnimation</code> 的一个实例，<code>move</code> 是它的<code>method</code>，返回的是一个<code>AnimationEntry</code>，所以写<code>anim:move(xxx):tint(xxx)</code>的时候，<code>tint</code>就是<code>AnimationEntry</code>的<code>method</code></p><p>Nova要保证<code>move</code>之类的函数不管前面是<code>NovaAnimation</code>还是<code>AnimationEntry</code>都能用，所以写了一个<code>make_anim_method</code> 来把它同时添加到两个类</p><h2 id="输入系统"><a href="#输入系统" class="headerlink" title="输入系统"></a>输入系统</h2><h2 id="存档系统"><a href="#存档系统" class="headerlink" title="存档系统"></a>存档系统</h2><p><a href="https://github.com/Lunatic-Works/Nova/wiki/Restoration">Nova Wiki: Restoration</a></p><h3 id="global-nsav"><a href="#global-nsav" class="headerlink" title="global.nsav"></a>global.nsav</h3><p>为了实现存档和读档的速度，Nova的存档系统将 <code>global.nsav</code> 按照固定长度分块，一个块被称为一个 CheckpointBlock，默认为4kB。</p><blockquote><p>这里需要区分 <code>CheckpointBlock</code> 与 <code>GameStateCheckpoint</code>，前一个是存档文件的分块，后一个是用于恢复游戏状态的数据。</p><p>相似的还有 <code>Record</code> 与 <code>NodeRecord</code>，前一个是数据存储进存档系统的基本单位，后一个是标识剧情进度的数据。</p></blockquote><p>为了避免每次读取数据都从global.nsav文件中读取，Nova的存档系统引入了 <code>LRUCache</code> 机制。（它是一种常见的缓存淘汰策略，在缓存空间有限时，优先淘汰最近最少使用的数据）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CheckpointSerializer GetBlock</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CheckpointBlock <span class="title">GetBlock</span>(<span class="params"><span class="built_in">long</span> id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cachedBlocks.TryGetValue(id, <span class="keyword">out</span> <span class="keyword">var</span> block))</span><br><span class="line">    &#123;</span><br><span class="line">        block = CheckpointBlock.FromFile(file, id);</span><br><span class="line">        cachedBlocks[id] = block;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CheckpointSerializer AppendBlock</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CheckpointBlock <span class="title">AppendBlock</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> id = endBlock++;</span><br><span class="line">    <span class="keyword">var</span> block = <span class="keyword">new</span> CheckpointBlock(file, id);</span><br><span class="line">    cachedBlocks[id] = block;</span><br><span class="line">    <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>global.nsav</code> 包含三种类型的数据：</p><ol><li><code>global save</code> 里面记录了存档时间标识和 <code>Reached</code> 数据以及 <code>Checkpoint</code> 数据在文件中的位置索引。</li><li><code>Reached链表</code>：存储所有已达剧情，<code>ReachedEndData</code>、<code>ReachedDialogueData</code>。<ol><li><code>ReachedDialogueData</code>：一条已读对话的信息，包括该对话的语音信息和文本是否需要插值。</li><li><code>ReachedEndData</code>一个已读结局的名称。</li></ol></li><li><code>Checkpoint链表</code>：存储游戏历史中的所有状态，例如游戏中的音频大小、文本的位置和内容。</li></ol><p>global.nsav的文件结构大致如下图所示。</p><p><img src="/images/nova-source-code_global.nsav-phy.svg" alt="global.nsav"></p><p>可以参照CheckpointBlock的Flush方法的实现来理解。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CheckpointBlock Flush</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Flush</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dirty || stream == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> version = BitConverter.GetBytes(CheckpointSerializer.Version);</span><br><span class="line">        <span class="keyword">var</span> header = CheckpointSerializer.FileHeader;</span><br><span class="line">        Buffer.BlockCopy(header, <span class="number">0</span>, data, <span class="number">0</span>, header.Length);</span><br><span class="line">        Buffer.BlockCopy(version, <span class="number">0</span>, data, header.Length, <span class="number">4</span>);</span><br><span class="line">        index += CheckpointSerializer.FileHeaderSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x = BitConverter.GetBytes(_nextBlock);</span><br><span class="line">    Buffer.BlockCopy(x, <span class="number">0</span>, data, index, HeaderSize);</span><br><span class="line">    stream.Seek(offset, SeekOrigin.Begin);</span><br><span class="line">    stream.Write(data, <span class="number">0</span>, BlockSize);</span><br><span class="line">    dirty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckpointBlock-类图"><a href="#CheckpointBlock-类图" class="headerlink" title="CheckpointBlock 类图"></a>CheckpointBlock 类图</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CheckpointBlock</span> &#123;</span><br><span class="line">    + BlockSize : <span class="built_in">int</span></span><br><span class="line">    + HeaderSize : <span class="built_in">int</span></span><br><span class="line">    + DataSize : <span class="built_in">int</span></span><br><span class="line">    $ GetBlockID(offset : <span class="built_in">long</span>) <span class="built_in">long</span></span><br><span class="line">    $ GetBlockIDIndex(offset : <span class="built_in">long</span>, <span class="keyword">out</span> <span class="built_in">int</span> index) <span class="built_in">long</span></span><br><span class="line">    + id : <span class="built_in">long</span></span><br><span class="line">    - offset : <span class="built_in">long</span></span><br><span class="line">    + dataOffset : <span class="built_in">long</span></span><br><span class="line">    + nextOffset : <span class="built_in">long</span></span><br><span class="line">    + segment : ByteSegment</span><br><span class="line">    - dirty : <span class="built_in">bool</span></span><br><span class="line">    - stream : Stream</span><br><span class="line">    - data : <span class="built_in">byte</span>[]</span><br><span class="line">    $ FromFile(Stream stream, <span class="built_in">long</span> id) CheckpointBlock</span><br><span class="line">    + MarkDirty() <span class="keyword">void</span></span><br><span class="line">    + Flush() <span class="keyword">void</span></span><br><span class="line">    + Dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何向global-nsav中添加记录"><a href="#如何向global-nsav中添加记录" class="headerlink" title="如何向global.nsav中添加记录"></a>如何向global.nsav中添加记录</h4><p><code>AppendRecord</code> 会首先在 <code>Record</code>的开头标记数据的大小，然后再将数据写入。</p><p>如果当前CheckpointBlock无法完全容纳数据，则剩余的数据将被写入下一个CheckpointBlock中。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendRecord</span>(<span class="params"><span class="built_in">long</span> offset, ByteSegment bytes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> block = GetBlockIndex(offset, <span class="keyword">out</span> <span class="keyword">var</span> index);</span><br><span class="line">    <span class="keyword">var</span> segment = block.segment;</span><br><span class="line">    <span class="keyword">if</span> (index + RecordHeader &gt; segment.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> CheckpointCorruptedException.RecordOverflow(offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    segment.WriteInt(index, bytes.Count);</span><br><span class="line">    index += RecordHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; bytes.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> size = Math.Min(segment.Count - index, bytes.Count - pos);</span><br><span class="line">        segment.WriteBytes(index, bytes.Slice(pos, size));</span><br><span class="line">        block.MarkDirty();</span><br><span class="line">        pos += size;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; bytes.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            block = NextBlock(block);</span><br><span class="line">            segment = block.segment;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ByteSegment"><a href="#ByteSegment" class="headerlink" title="ByteSegment"></a>ByteSegment</h3><pre><code class="highlight mermaid">classDiagramclass ByteSegment &#123;    - array: byte[]    %% 表示字节片段的起始位置在数组中的偏移量。    - offset: int    %% 表示字节片段的长度    + Count: int    + Slice(offset: int, count: int) ByteSegment    + Slice(offset: int) ByteSegment    + ToStream() MemoryStream    + ReadInt(offset: int) int    + ReadLong(offset: int) long    + ReadUlong(offset: int) ulong    + WriteInt(offset: int, value: int) void    + WriteLong(offset: int, value: long) void    + WriteUlong(offset: int, value: ulong) void    + ReadBytes(offset: int, bytes: byte[]) void    + ReadBytes(offset: int, bytes: ByteSegment) void    + ReadString(offset: int, count: int) string    + ReadString(offset: int) string    + WriteBytes(offset: int, bytes: byte[]) void    + WriteBytes(offset: int, bytes: ByteSegment) void    + WriteString(offset: int, str: string) void&#125;</code></pre><h3 id="CheckpointManager-CheckpointSerializer"><a href="#CheckpointManager-CheckpointSerializer" class="headerlink" title="CheckpointManager &amp; CheckpointSerializer"></a>CheckpointManager &amp; CheckpointSerializer</h3><p>存储数据的初始化由 <code>CheckpointManager</code> 类负责。在这里，会初始化<code>GlobalSave</code>、<code>ReachedEndData</code>和<code>ReachedDialogueData</code>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CheckpointManager Init</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    serializer = <span class="keyword">new</span> CheckpointSerializer(globalSavePath);</span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(globalSavePath))</span><br><span class="line">    &#123;</span><br><span class="line">        ResetGlobalSave();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        serializer.Open();</span><br><span class="line">        InitGlobalSave();</span><br><span class="line">        InitReached();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> fileName <span class="keyword">in</span> Directory.GetFiles(savePathBase, <span class="string">&quot;sav*.sav*&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = Regex.Match(fileName, <span class="string">@&quot;sav([0-9]+)\.sav&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (result.Groups.Count &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">int</span>.TryParse(result.Groups[<span class="number">1</span>].Value, <span class="keyword">out</span> <span class="built_in">int</span> id))</span><br><span class="line">        &#123;</span><br><span class="line">            bookmarksMetadata.Add(id, <span class="keyword">new</span> BookmarkMetadata</span><br><span class="line">            &#123;</span><br><span class="line">                saveID = id,</span><br><span class="line">                modifiedTime = File.GetLastWriteTime(fileName)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inited = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitGlobalSave</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    globalSave = serializer.DeserializeRecord&lt;GlobalSave&gt;(CheckpointSerializer.GlobalSaveOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitReached</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    reachedDialogues.Clear();</span><br><span class="line">    reachedEnds.Clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> cur = globalSave.beginReached;</span><br><span class="line">         cur &lt; globalSave.endReached;</span><br><span class="line">         cur = serializer.NextRecord(cur))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">record</span> = serializer.DeserializeRecord&lt;IReachedData&gt;(cur);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">record</span> <span class="title">is</span> <span class="title">ReachedEndData</span> <span class="title">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reachedEnds.Add(end.endName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">record</span> <span class="title">is</span> <span class="title">ReachedDialogueData</span> <span class="title">dialogue</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            SetReachedDialogueData(dialogue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">record</span> <span class="title">is</span> <span class="title">NodeUpgradeMaker</span> <span class="title">maker</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reachedDialogues.Remove(maker.nodeName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check each reached data is a prefix</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> reachedList <span class="keyword">in</span> reachedDialogues)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reachedList.Value.Contains(<span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> CheckpointCorruptedException.BadReachedData(reachedList.Key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CheckpointSerializer 类是用于序列化和反序列化游戏数据的关键部分。</p><pre><code class="highlight mermaid">classDiagramclass ISerializationBinder &#123;    &lt;&lt;interface&gt;&gt;    + BindToType(string? assemblyName, string typeName) Type    + BindToName(Type serializedType, out string? assemblyName, out string? typeName) void&#125;JsonTypeBinder --|&gt; ISerializationBinderclass JsonTypeBinder &#123;    $ Assembly CurAssembly    $ HashSet~Assembly~ AllowedAssembly    $ IsPrimitiveType(Type serializedType, bool checkAssembly = true) bool    $ IsAllowedAssembly(Type serializedType) bool    - IsGameType(Type serializedType) bool    - IsAllowedType(Type serializedType) bool    + BindToName(Type serializedType, out string assemblyName, out string typeName) void    + BindToType(string assemblyName, string typeName) Type&#125;CheckpointJsonSerializer *-- JsonTypeBinderCheckpointJsonSerializer --&gt; JsonSerializerCheckpointSerializer *-- CheckpointJsonSerializerclass CheckpointSerializer &#123;    + Version : int    %% 存档文件头的字节数据和大小。    + FileHeader : byte[]    + FileHeaderSize : int    + GlobalSaveOffset : int    - DefaultCompress : bool    - RecordHeader : int    %% 一个 CheckpointJsonSerializer 实例，用于 JSON 序列化和反序列化存档数据。    - jsonSerializer : JsonSerializer    - path : string    %% FileStream 实例，用于操作存档文件。    - file : FileStream    %% 存档中最后一个块的编号。    - endBlock : long    %% 一个 LRUCache，用于缓存存档块数据，提高读取性能。    - cachedBlocks : LRUCache~long, CheckpointBlock~    + Open()    + Dispose()    - GetBlock(long id) CheckpointBlock    - GetBlockIndex(long offset, out int index) CheckpointBlock    + GetRecord(long offset) ByteSegment    + GetNodeRecord(long offset) NodeRecord    - AppendBlock() CheckpointBlock    - NextBlock(CheckpointBlock block) CheckpointBlock    + BeginRecord() long    + NextRecord(long offset) long    + AppendRecord(long offset, ByteSegment bytes) void    + UpdateNodeRecord(NodeRecord record) void    + SerializeRecord~T~(long offset, T data, bool compress = DefaultCompress) void    + DeserializeRecord~T~(long offset, bool compress = DefaultCompress) T    + ReadBookmark(string path, bool compress = DefaultCompress) Bookmark    + WriteBookmark(string path, Bookmark obj, bool compress = DefaultCompress) void&#125;</code></pre><pre><code class="highlight mermaid">classDiagramclass CheckpointManager &#123;    - saveFolder : string    - frozen : bool    - savePathBase : string    - globalSavePath : string    - backupPath : string    - globalSave : GlobalSave    - globalSaveDirty : bool    - reachedDialogues : Dictionary&amp;lt; string,List~ReachedDialogueData~ &amp;gt;    - reachedEnds : SerializableHashSet~string~    - cachedBookmarks : Dictionary~int, Bookmark~    + bookmarksMetadata : Dictionary~int, BookmarkMetadata~    - serializer : CheckpointSerializer    - inited : bool    + Init() void    + NextRecord() long    + InitReached() void    + NewReached() void    + SetReachedDialogueData(data : ReachedDialogueData) void    + AppendReachedRecord(data : IReachedData) void    + SetReached(data : ReachedDialogueData)    + SetEndReached(endName : string)    + IsReachedAnyHistory(string nodeName, int dialogueIndex) bool    + GetReachedDialogueData(string nodeName, int dialogueIndex) ReachedDialogueData    + IsEndReached(string endName) bool    + InvalidateReachedData(string nodeName) void    + beginNodeOffset : long    - NewCheckpointRecord() void    + NextCheckpoint(long offset) long    + GetNextNode(NodeRecord prevRecord, string name, Variables variables, int beginDialogue) NodeRecord    + GetNodeRecord(long offset) NodeRecord    + CanAppendCheckpoint(long checkpointOffset) bool    + AppendDialogue(NodeRecord nodeRecord, int dialogueIndex, bool shouldSaveCheckpoint) void    + AppendCheckpoint(int dialogueIndex, GameStateCheckpoint checkpoint) long    + GetCheckpointDialogue(long offset) int    + GetCheckpoint(long offset) GameStateCheckpoint    %% 这里是CheckpointUpgrade，和核心系统关系不大，暂时省略    - InitGlobalSave() void    - UpdateGlobalSave() void    - ResetGlobalSave() void    + BackupGlobalSave() void    + RestoreGlobalSave() void    - GetBookmarkFileName(int saveID) string    - ReplaceCache(int saveID, Bookmark bookmark) Bookmark    + SaveBookmark(int saveID, Bookmark bookmark, bool cache = true) void    + LoadBookmark(int saveID, bool cache = true) Bookmark    + DeleteBookmark(int saveID) void    + EagerLoadRange(int beginSaveID, int endSaveID) void&#125;</code></pre><h3 id="Bookmark"><a href="#Bookmark" class="headerlink" title="Bookmark"></a>Bookmark</h3><p>存档&#x2F;读档界面中的每个存档称为书签（Bookmark），记录nodeOffset、checkpointOffset、dialogueIndex</p><p>自动存档、快速存档与手动存档的格式是一样的</p><pre><code class="highlight mermaid">classDiagramclass Bookmark &#123;    + ScreenshotWidth : int    + ScreenshotHeight : int    + nodeOffset : long    + checkpointOffset : long    + dialogueIndex : int    + description : DialogueDisplayData    + creationTime : DateTime    + globalSaveIdentifier : long    + screenshotBytes : byte[]    + screenshotTexture : Texture2D    + screenshot : Texture2D&#125;</code></pre><h3 id="NodeRecord"><a href="#NodeRecord" class="headerlink" title="NodeRecord"></a>NodeRecord</h3><pre><code class="highlight mermaid">classDiagramclass NodeRecord &#123;    - HeaderSize : int    + offset : long    + child : long    + sibling : long    + beginDialogue : int    + endDialogue : int    + lastCheckpointDialogue : int    + variablesHash : ulong    + name : string    + ToByteSegment() ByteSegment&#125;</code></pre><h3 id="RestoreData-and-SerializedData"><a href="#RestoreData-and-SerializedData" class="headerlink" title="RestoreData and SerializedData"></a>RestoreData and SerializedData</h3><p><strong>GameStateCheckpoint</strong></p><p>该类存储游戏对象下所有已注册可还原器在某一步的所有还原信息。</p><p>由于脚本语法的设计，只有在运行时才能知道每一步的对象状态。</p><p>为了实现后退功能，游戏状态对象应知道每一步的所有 GameStateRestoreEntry，以便执行后退。为使后退功能在从检查点加载后仍能正常工作，CheckpointManager 应存储所有走过的对话框的 GameStateRestoreEntry。</p><pre><code class="highlight mermaid">classDiagramclass ISerializedData &#123;    &lt;&lt;interface&gt;&gt;&#125;IRestoreData --|&gt; ISerializedDataclass IRestoreData &#123;    &lt;&lt;interface&gt;&gt;&#125;IReachedData --|&gt; ISerializedDataclass IReachedData &#123;    &lt;&lt;interface&gt;&gt;&#125;GameStateCheckpoint --&gt; ISerializedDataclass GameStateCheckpoint &#123;    + dialogueIndex : int    + stepsCheckpointRestrained : int    + restoreDatas : Dictionary~string, IRestoreData~    + variables : Variables&#125;ReachedEndData --&gt; IReachedDataclass ReachedEndData &#123;    + endName: string&#125;ReachedDialogueData --&gt; IReachedDataclass ReachedDialogueData &#123;    + nodeName : string    + dialogueIndex : int    + voices : VoiceEntries    + needInterpolate: bool    + textHash : string&#125;class ReachedDialoguePosition &#123;    + nodeRecord ： NodeRecord    + checkpointOffset : long    + dialogueIndex : int&#125;</code></pre><pre><code class="highlight mermaid">classDiagramclass GlobalSave &#123;    + identifier : long    + beginReached : long    + endReached : long    + beginCheckpoint : long    + endCheckpoint : long    + nodeHashes : Dictionary~string, ulong~    + data : Dictionary~string, object~&#125;</code></pre><h3 id="IRestorable"><a href="#IRestorable" class="headerlink" title="IRestorable"></a>IRestorable</h3><p>IRestorable 接口代表一个对象，当 GameState 向后移动时，该对象会恢复其状态。</p><pre><code class="highlight mermaid">classDiagramclass IRestorable &#123;    + restorableName : string    + GetRestoreData() IRestoreData    + Restore(restoreData : IRestoreData) void&#125;</code></pre><h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><p>GameState 记录了AVG的所有状态，因此只要将游戏的 GameState 回退到某个时刻，就能实现游戏的进度回退。</p><pre><code class="highlight mermaid">classDiagramclass GameState &#123;    - scriptPath : string    - scriptLoader : ScriptLoader    - flowChartGraph : FlowChartGraph    - checkpointManager : CheckpointManager    - initialCheckpoint : GameStateCheckpoint    - advancedDialogueHelper : AdvancedDialogueHelper    - coroutineHelper : CoroutineHelper    - nodeRecord : NodeRecord    - checkpointOffset : long    - currentNode : FlowChartNode    - currentIndex : int    - currentDialogueEntry : DialogueEntry    - variables : Variables    - state : State    - isEnded : bool    + ResetGameState() void    + gameStarted : UnityEvent    + nodeChanged : NodeChangedEvent    + dialogueWillChange : UnityEvent    + dialogueChangedEarly : DialogueChangedEvent    + dialogueChanged : DialogueChangedEvent    + selectionOccurs : SelectionOccursEvent    + routeEnded : RouteEndedEvent    + restoreStarts : UnityEvent    - currentVoices Dictionary~string, VoiceEntry~    + AddVoice(string characterName, VoiceEntry voiceEntry) void    - actionCoroutine : Coroutine    - ExecuteAction(IEnumerator coroutine) void    - CancelAction() void    - ResetActionContext() void    - actionPauseLock : CounterLock    + AcquireActionPause() void    + ReleaseActionPause() void    - variablesHashBeforeInterrupt : ulong    + StartInterrupt() void    + StopInterrupt() void    + SignalFence(object value) void    - UpdateGameState(bool nodeChanged, bool dialogueChanged, bool firstEntryOfNode, bool dialogueStepped, bool fromCheckpoint) void    - UpdateDialogue(bool firstEntryOfNode, bool dialogueStepped, bool fromCheckpoint) IEnumerator    - StepCheckpoint(bool isReached) void    - DialogueSaveCheckpoint(bool firstEntryOfNode, bool dialogueStepped) bool    - DialogueSaveReachedData(out ReachedDialogueData dialogueData) bool    - StepAtEndOfNode() void    - AppendSameNode() void    - MoveToNextNode(FlowChartNode nextNode) void    - DoBranch(IEnumerable&lt;BranchInformation&gt; branchInfos) IEnumerator    - SelectBranch(string branchName) void    - SaveInitialCheckpoint() void    - GameStart(FlowChartNode startNode) void    + GameStart(string nodeName) void    + GetNode(string name, bool addDeferred = true) FlowChartNode    + GetStartNodeNames(StartNodeType type = StartNodeType.Normal) IEnumerable~string~    + canStepForward : bool    + Step() void    + RaiseSelections(IReadOnlyList&lt;SelectionOccursData.Selection&gt; selections) void    - Dictionary~string, IRestorable~ restorables    + AddRestorable(IRestorable restorable) void    + RemoveRestorable(IRestorable restorable) void    %% 并非所有对象的状态都能轻易恢复，比如保持动画。    %% 我们会存储一些检查点，其他状态可以通过从上一个检查点重新执行来恢复。    %% 从最后一个检查点开始每隔 maxStepsFromLastCheckpoint 至少会保存一个检查点，保持动画期间除外。    - maxStepsFromLastCheckpoint : int    + WarningStepsFromLastCheckpoint : int    - stepsFromLastCheckpoint : int    - stepsCheckpointRestrained : int    - checkpointRestrained : bool    + RestrainCheckpoint(int steps, bool overridden = false) void    %% 用于在保持动画开始前强制保存检查点。    - bool checkpointEnsured    %% 在使用 anim_hold_begin 时由预载系统使用    %% 当前对话是否有检查点是在 Lua 代码运行之前决定的、所以我们只能在下一次对话中确保它    + EnsureCheckpointOnNextDialogue() void    - appendNodeEnsured : bool    - atEndOfNodeRecord : bool    - shouldSaveCheckpoint : bool    - GetCheckpoint() GameStateCheckpoint    - RestoreCheckpoint(GameStateCheckpoint entry) void    - SeekBackStep(int steps, IList~NodeRecord~ nodeHistory, out long newCheckpointOffset, out int newDialogueIndex) void    - SeekBackStep(int steps, out NodeRecord nodeRecord, out long newCheckpointOffset, out int newDialogueIndex) void    + isUpgrading : bool    + isRestoring : bool    - CheckUnlockInRestoring() bool    - FastForward(int stepCount) void    - Move(NodeRecord newNodeRecord, long newCheckpointOffset, int dialogueIndex, bool upgrade) void    + MoveBackTo(NodeRecord newNodeRecord, long newCheckpointOffset, int dialogueIndex) void    + MoveToUpgrade(NodeRecord newNodeRecord, int lastDialogue) void    + MoveBackToFirstDialogue() void    %% Move to previous/next chapter/branch.    + MoveToKeyPoint(bool forward, bool allowChapter, bool allowBranch = true) void    + GetDialogueHistory(int limit = 0) IEnumerable~ReachedDialoguePosition~    + GetBookmark() Bookmark    + LoadBookmark(Bookmark bookmark) void&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> game development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在vscode中为c#编写单元测试</title>
      <link href="/2024/05/12/writing_unit_tests_for_csharp_in_vscode/"/>
      <url>/2024/05/12/writing_unit_tests_for_csharp_in_vscode/</url>
      
        <content type="html"><![CDATA[<h2 id="如何从零开始创建一个单元测试工程"><a href="#如何从零开始创建一个单元测试工程" class="headerlink" title="如何从零开始创建一个单元测试工程"></a>如何从零开始创建一个单元测试工程</h2><p><strong>创建测试单元工程</strong></p><p>创建测试文件的方法和新建项目类似，都是使用<code>dotnet new</code>命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dotnet new xunit</span><br></pre></td></tr></table></figure><p><strong>为测试单元工程添加需要测试的工程的项目引用</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dotnet add reference ..\program\program.csproj</span><br></pre></td></tr></table></figure><p><strong>为sln文件添加测试单元工程的项目引用</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dotnet sln add ..\program.test\program.test.csproj</span><br></pre></td></tr></table></figure><p>文件的目录结构应大致如下树状图所示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">├─program/</span><br><span class="line">│├─src/</span><br><span class="line">│└─program.csproj</span><br><span class="line">├─program.test/</span><br><span class="line">│├─src/</span><br><span class="line">│└─program.test.csproj</span><br><span class="line">└─program.sln</span><br></pre></td></tr></table></figure><p><strong>运行测试单元</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dotnet test</span><br></pre></td></tr></table></figure><h2 id="单元测试中如何输出日志"><a href="#单元测试中如何输出日志" class="headerlink" title="单元测试中如何输出日志"></a>单元测试中如何输出日志</h2><blockquote><p>Q：xUnit为什么没有办法直接打印输出？</p><p>A：xUnit的测试会新开一个进程进行测试，因此运行<code>dotnet test</code>命令的进程没有办法捕获xUnit进程的输出。</p></blockquote><p>解决方案：在测试代码中添加<code>ITestOutputHelper</code>接口，并在构造函数中将其初始化，之后使用该接口的WriteLine方法输出文本。</p><span id="more"></span><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Xunit;</span><br><span class="line"><span class="keyword">using</span> Xunit.Abstractions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ITestOutputHelper output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestClass</span>(<span class="params">ITestOutputHelper output</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化接口</span></span><br><span class="line">        <span class="keyword">this</span>.output = output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyTest</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = <span class="string">&quot;my class!&quot;</span>;</span><br><span class="line">        output.WriteLine(<span class="string">&quot;This is output from &#123;0&#125;&quot;</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里要注意的是，vscode中如果想要看到标准输出，需要在<code>dotnet test</code>命令后添加额外的参数<code>--logger &quot;console;verbosity=detailed&quot;</code>，也就是运行以下命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dotnet test --logger &quot;console;verbosity=detailed&quot;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-with-dotnet-test">Microsoft：使用 dotnet test 和 xUnit 在 .NET 中对 C# 进行单元测试</a></p><p><a href="https://zhuanlan.zhihu.com/p/386588635">知乎：VSCode + xUnit 编写 C# 单元测试</a></p><p><a href="https://xunit.net/docs/capturing-output">xUnit：Capturing Output</a></p><p><a href="https://www.cnblogs.com/dudu/p/9391959.html">博客园：终于解决 xUnit.net 测试中无法输出到控制台的问题</a></p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> csharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何编译Godot（Godot &amp; Godot with C#）</title>
      <link href="/2024/05/11/how_to_build_godot_and_godot_for_csharp/"/>
      <url>/2024/05/11/how_to_build_godot_and_godot_for_csharp/</url>
      
        <content type="html"><![CDATA[<p>要在Windows下编译Godot, 需要以下环境:</p><ul><li><p><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">Visual Studio Community</a>：使用最新版本。</p></li><li><p><a href="https://mingw-w64.org/">MinGW-w64</a>：可以替代 Visual Studio。请务必将其安装&#x2F;配置为使用 posix 线程模型。使用 MinGW 编译主分支时，需要 GCC 9 或更高版本。</p></li><li><p><a href="https://www.python.org/downloads/windows/">Python 3.6+</a>：确保在安装程序中启用将 Python 添加到环境变量中。</p></li><li><p><a href="https://scons.org/pages/download.html">SCons 3.0+</a>：构建系统。建议使用最新版本，特别是为了正确支持最近发布的 Visual Studio。</p></li></ul><span id="more"></span><p>为了方便起见，建议使用 <code>scoop</code> 安装所需的软件，因为它会默认将软件的路径配置到环境变量，相较于手动安装更省事一些。</p><p><strong>安装scoop</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</span><br><span class="line">Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression</span><br></pre></td></tr></table></figure><p><strong>为 Scoop 设置代理</strong></p><blockquote><p>可选：如果你的scoop无法正常下载应用</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">scoop config proxy ip:port</span></span><br><span class="line">scoop config proxy 127.0.0.1:7890</span><br></pre></td></tr></table></figure><p><strong>安装环境</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scoop install gcc python scons make mingw</span><br></pre></td></tr></table></figure><p><strong>安装 scons</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m pip install scons</span><br></pre></td></tr></table></figure><h2 id="编译-Godot"><a href="#编译-Godot" class="headerlink" title="编译 Godot"></a>编译 Godot</h2><p><strong>下载源代码</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/godotengine/godot.git</span><br></pre></td></tr></table></figure><p><strong>使用 scons 编译源代码</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scons platform=windows</span><br></pre></td></tr></table></figure><p>等待编译完成后，可执行文件可在 <code>godot/bin/</code> 目录下看到。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">godot</span><br><span class="line">└─bin</span><br><span class="line">  └─godot.windows.editor.x86_64.console.exe</span><br><span class="line">  └─godot.windows.editor.x86_64.exe</span><br><span class="line">  └─godot.windows.editor.x86_64.exp</span><br><span class="line">  └─godot.windows.editor.x86_64.lib</span><br></pre></td></tr></table></figure><h2 id="编译-Godot-with-C"><a href="#编译-Godot-with-C" class="headerlink" title="编译 Godot with C#"></a>编译 Godot with C#</h2><p>使用源代码构建出 mono 版本的godot需要安装 <a href="https://dotnet.microsoft.com/en-us/download/dotnet">.NET SDK</a></p><p><strong>下载源代码</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/godotengine/godot.git</span><br></pre></td></tr></table></figure><p><strong>使用 scons 编译源代码</strong></p><p>若要启用 <code>godot</code> 的 <code>c#</code> 支持，需要在构建时添加 <code>module_mono_enabled=yes</code> 命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scons platform=windows module_mono_enabled=yes</span><br></pre></td></tr></table></figure><p>命令执行后，godot的文件目录结构应如下所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">godot</span><br><span class="line">└─bin</span><br><span class="line">  └─godot.windows.editor.x86_64.mono.console.exe</span><br><span class="line">  └─godot.windows.editor.x86_64.mono.exe</span><br><span class="line">  └─godot.windows.editor.x86_64.mono.exp</span><br><span class="line">  └─godot.windows.editor.x86_64.mono.lib</span><br></pre></td></tr></table></figure><p>但此时的 <code>godot mono</code> 还无法运行，我们需要为其添加绑定。</p><p><strong>使用 godot mono 生成 .Net glue</strong></p><p>在 godot 目录下输入以下命令。</p><p>该命令将指示 Godot 在 <code>godot/modules/mono/glue/GodotSharp/GodotSharp/Generated</code> 目录下生成 Godot API 的 C# 绑定文件，并在 <code>godot/modules/mono/glue/GodotSharp/GodotSharpEditor/Generated</code> 目录下生成编辑器工具的 C# 绑定文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/godot.windows.editor.x86_64.mono --headless --generate-mono-glue modules/mono/glue</span><br></pre></td></tr></table></figure><p><strong>使用python脚本依照glue生成托管库</strong></p><p>生成 <code>.NET glue</code> 后，可以使用脚本生成托管库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 ./modules/mono/build_scripts/build_assemblies.py --godot-output-dir=./bin</span><br></pre></td></tr></table></figure><p>命令执行后，<code>bin/</code> 目录下应该会生成出一个 <code>GodotSharp</code> 目录。</p><p>有了它，godot mono 就可以使用 c# 开发项目了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">godot</span><br><span class="line">└─bin</span><br><span class="line">  └─GodotSharp/</span><br><span class="line">  └─godot.windows.editor.x86_64.mono.console.exe</span><br><span class="line">  └─godot.windows.editor.x86_64.mono.exe</span><br><span class="line">  └─godot.windows.editor.x86_64.mono.exp</span><br><span class="line">  └─godot.windows.editor.x86_64.mono.lib</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://scoop.sh/">Scoop</a></p><p><a href="https://github.com/ScoopInstaller/scoop/wiki/Using-Scoop-behind-a-proxy">Scoop Proxy</a></p><p><a href="https://docs.godotengine.org/zh-cn/4.x/contributing/development/compiling/compiling_for_windows.html">Godot Docs：Compiling for windows</a></p><p><a href="https://docs.godotengine.org/en/stable/contributing/development/compiling/compiling_with_dotnet.html">Godot Docs：Compiling with dotnet</a></p>]]></content>
      
      
      <categories>
          
          <category> game development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Book &amp; Video &amp; Game Record List</title>
      <link href="/2024/04/13/bvg-list/"/>
      <url>/2024/04/13/bvg-list/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">Name</th><th align="left">Type</th><th align="left">Date</th></tr></thead><tbody><tr><td align="left">Evangelion: Air&#x2F;真心为你</td><td align="left">Video</td><td align="left">2024&#x2F;04&#x2F;13</td></tr><tr><td align="left">Evangelion: 破</td><td align="left">Video</td><td align="left">2024&#x2F;04&#x2F;13</td></tr><tr><td align="left">Evangelion: Q</td><td align="left">Video</td><td align="left">2024&#x2F;04&#x2F;15</td></tr><tr><td align="left">Evangelion: 终</td><td align="left">Video</td><td align="left">2024&#x2F;04&#x2F;19</td></tr><tr><td align="left">流浪地球制作手记</td><td align="left">Book</td><td align="left">2024&#x2F;05&#x2F;01</td></tr><tr><td align="left">全部成为F</td><td align="left">Video</td><td align="left">2024&#x2F;06&#x2F;01</td></tr><tr><td align="left">贝果爱情故事</td><td align="left">Game</td><td align="left">2024&#x2F;08&#x2F;04</td></tr><tr><td align="left">搞定I：无压力工作的艺术</td><td align="left">Book</td><td align="left">2024&#x2F;07&#x2F;06</td></tr><tr><td align="left">旧制度与大革命</td><td align="left">Book</td><td align="left">2024&#x2F;07&#x2F;10</td></tr><tr><td align="left">世界秩序</td><td align="left">Book</td><td align="left">2024&#x2F;07&#x2F;12</td></tr><tr><td align="left">1973年的弹子球</td><td align="left">Book</td><td align="left">2024&#x2F;07&#x2F;13</td></tr><tr><td align="left">萤</td><td align="left">Book</td><td align="left">2024&#x2F;07&#x2F;15</td></tr><tr><td align="left">Unity人工智能游戏开发</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;08</td></tr><tr><td align="left">Unity3D人工智能编程精粹</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;08</td></tr><tr><td align="left">怎样做成大事</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;12</td></tr><tr><td align="left">检查力：打破信息茧房</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;14</td></tr><tr><td align="left">Unity API 解析</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;16</td></tr><tr><td align="left">魔法使之夜</td><td align="left">Game</td><td align="left">2024&#x2F;08&#x2F;18</td></tr><tr><td align="left">游戏架构: 核心技术与面试精粹</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;18</td></tr><tr><td align="left">Effective CSharp</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;19</td></tr><tr><td align="left">CSharp 7.0 核心技术指南</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;23</td></tr><tr><td align="left">烧掉数学书: 重新发明数学</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;24</td></tr><tr><td align="left">微积分的力量</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;24</td></tr><tr><td align="left">纯爱独白: 小小</td><td align="left">Game</td><td align="left">2024&#x2F;08&#x2F;26</td></tr><tr><td align="left">计算机：一部历史</td><td align="left">Book</td><td align="left">2024&#x2F;08&#x2F;27</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> record </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
